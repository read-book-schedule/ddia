#  **一、可靠性、可扩展性、可维护性**

平台的设计优先考虑灵活性（flexibility）和弹性（elasticity）,而不是单机可靠性

## 1.可靠性（Reliability）

系统在困境（adversity）(硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。

### 保证可靠性

设计容错机制以防因故障而导致失效（通过 Chaos Monkey 来故意触发故障，进而确保容错机制不断运行并接受考验。[Netflix]）

### 故障的区分

#### 1.1 硬件故障

增加单个硬件的冗余

#### 1.2 软件错误

原因：假设由于某种原因不成立

处理方法

* 仔细考虑系统中的假设和交互；

* 彻底的测试；

* 进程隔离；

* 允许程序崩溃并重启；

* 测量、监控并分析生产环境中的系统行为

#### 1.3 人为错误

* 以最小化犯错机会的方式设计系统；
* 将容易犯错的地方与可能导致失效的地方解耦（沙箱环境）；
* 彻底的测试（单元，集成，自动化测试）；
* 允许从人为错误中简单快速的恢复（回滚配置，分批发布新代码，提供数据重算工具-防止旧的计算出错）；
* 配置详细和明确的监控；
* 良好的管理实践与充分的培训；

## 2.可扩展性（Scalability）

有合理的办法应对系统的增长（数据量、流量、复杂性）

相关点：

* 描述负载 - QPS, 数据库的读写比率等

* 描述性能 - 分位点

  Q1 . 增加负载但是资源不变性能怎么样？

  Q2 . 增加负载性能不变，要加多少资源？

  服务级别目标（SLO, service level objectives）

  服务级别协议（SLA, service level agreements

  批处理关心吞吐量，在线系统关心响应时间

* 应对负载的方法

  纵向扩展（垂直扩展）[更强大的机器]；

  横向扩展（水平扩展）[多台机器]

  

**延迟**：某个请求等待处理的持续时长，在此期间它处于休眠状态，并等待服务；

**响应时间** ：客户看到的除了实际处理时间之外，还包括网络延迟和排队延迟。

**头部阻塞**：少量缓慢请求阻碍后续的请求处理；

**尾部延迟放大**：小部分后端调用速度慢，如果一个请求需要调用多个后端服务，较慢调用机会增加，较高比例的用户请求速度变慢；

## 3.可维护性（Maintainability）

许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保留现有行为，并适应新的应用场景）

### 关注设计的三个原则：

#### 3.1 可操作性（Operability）

运维简单

#### 3.2 简单性（Simplicity）

管理复杂度（消除额外复杂度⇒抽象）

#### 3.3 可演化性（evolability）

也可以描述为 可扩展性，可修改性，可塑性

拥抱变化 ⇒ 敏捷开发（TDD, test-driven development）和重构（refactoring）



# **二、数据模型与查询语言**

## 1.数据模型

应用使用层层叠加的数据模型构建，每一层都通过提供一个明确的数据模型来隐藏更低层次的复杂性；

**阻抗不匹配（impedance mismatch）**：模型之间的不连贯;

**读时模式（scheme-on-read）**：数据的结构时隐含的，数据被读取时才会解释；

**写时模式（scheme-on-write）**：数据在写入时有固定的结构；

读时模式类似于运行时动态检查，写时模式类似于编译时静态类型检查；

### 1.1 关系模型：强制模式

特点：数据被组成关系（SQL 中的表），每个关系是元组（SQL 中的行）的无序集合；

优点：查询优化器决定什么顺序执行及使用那些索引（类似于访问路径）

缺点：对象关系不匹配（需要转换）

场景：1:n,n:1,n:n；

### 1.2 文档模型（层次模型）：架构灵活，不强制模式

优点：架构灵活，更好的扩展性，局部性良好

缺点：不适合多对一，多对多（需要引入文档引用[类似于外键]）

建议：由于局部性仅仅适用于需要文档绝大部分内容的情况，因此建议保持相对小的文档，避免增加文档大小的写入

场景：1:n；自包含；文档之间无关系或者关系稀少；

### 1.3 **图数据模型**：不强制模式

顶点（vertices）(也称节点（nodes）或实体（entities）)

边（edges）(也称关系（relationships）或弧（arcs）)

优点：处理复杂关系，更大的灵活性

实现：属性图模型，三元组存储；

场景：n:n（社交图谱，网络图谱，公路或铁路网络）⇒ 最短路径，网页流行程度；

## **2. 数据查询语言**

### 查询语言

- Cypher（属性图的声明式查询语言）,

- SPARQL（三元组存储的面向RDF数据模型的查询语言）

- DataLog（类似于三元组（谓语（主语 宾语）））



**属性图**：

每个**顶点（vertex）**包括：

- 唯一的标识符
- 一组 **出边（outgoing edges）**
- 一组 **入边（ingoing edges）**
- 一组属性（键值对）

每条 **边（edge）** 包括：

- 唯一标识符
- **边的起点/尾部顶点（tail vertex）**
- **边的终点/头部顶点（head vertex）**
- 描述两个顶点之间关系类型的标签
- 一组属性（键值对）

**三元组**：三部分表示形式存储（主语，谓语，宾语）



#### 2.1 声明式

指定所需数据的模式-结果必须符合哪些条件，以及如何将数据转换（排序，分组和集合）-但不是如何实现这一目标。

优点：

1. 更简洁和容易；
2. 隐藏了数据库引擎的实现细节（底层修改可以不影响使用）；
3. 不在意顺序（有排序方法）；
4. 适合并行执行（仅指定结果的模式，不指定确定结果的算法）；

eg：css 样式（选中的父级所有子集改变颜色）

#### 2.2 命令式

告诉计算机以特定顺序执行某些操作（逐行遍历代码，评估条件，更新变量，并决定是否再循环一遍）

缺点：

1. 不能确定代码是否依赖于排序；
2. 难在多个内核和多个机器之间并行化（指令必须以特定顺序执行）；

eg：JavaScript 操作 DOM

# 三、总结

学到了很多的概念，了解到了数据模型的发展历程（关系模型的统治，其它模型的挑战），及相关模型的优缺点和适用场景。

