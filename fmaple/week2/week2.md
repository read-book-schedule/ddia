# 一、存储与检索

## 存储引擎类别

### 1 日志结构（log-structured）

实现：SSTable(Sorted String table) 和 LSM 树

工作流程：

* 写入时，将数据写入到内存中的平衡树数据结构（红黑树）。这个内存有时被称为内存表（memtable）
* 当内存表大于某个阈值（几兆字节）时，将其作为 SSTable 文件写入磁盘。新的 SSTable 成为数据库的最新部分。当 SSTable 被写入磁盘时，写入可以继续到一个新的内存实例。
* 为了提供读取请求，首先尝试在内存表中搜索关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字
* 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值

优点：写入速度更快（追加），文件更小

缺点：查询速度会比较慢，当查询一个不存在的数据时可能得借助 Bloom 过滤器

### 2 面向页面（page-oriented）

实现：B 树

流程：将数据库分解成固定大小的块或页面，传统上大小为 4kB (有时会更大)，并且一次只能读取或写入一个页面。每个页面都可以使用地址或位置来标识，这允许一个页面引用另一个页面 — 类似于指针，但在磁盘而不是在内存中。

分支因子：一个页面中对子页面的引用的数量称为分子银子。

包含单个键（叶页）的页面，该页面包含每个键的内联值，或则和包含对可以找到值的页面的引用。

修改：当更新B树中现有键的值，则搜索包含该键的叶页，更改该页中的值，并将该页写回到磁盘（对该页的任何引用保持有效）。当添加一个新的键，需要找到其范围包含新键的页面，并将其添加到该页面。如果页面中没有足够的可用空间容纳新键，则将其分成两个半满页面，并更新父页面以解释键范围的新分区。

预写式日志（WAL, write-ahead-log）(也称重做日志（redo log）): 额外的磁盘数据结构，仅追加，在数据库崩溃后恢复一致。

优点：读取速度快

缺点：会占用一些未使用的空间

优化：

* 使用写实复制方案代替覆盖页面并维护WAL进行崩溃恢复。修改的页面被写入到不同的位置，并且树中的父页面的新版本本创建，指向新的位置。
* 不存储整个键来节省页面空间，可以缩小大小。在树内部的页面上，键只需要提供足够的信息来充当键范围之间的边界。页面中包含更多的键允许树具有更高的分支因子，更少的层次
* 页面放置在磁盘上的任何位置。尝试布局树，使得叶子页面按顺序出现在磁盘上。
* 额外的指针添加到树种。例如：每个叶子页面可以在左边和右边具有对兄弟页面的引用，允许不跳回夫页面就能顺序扫描



## 数据仓库

分析的模式：星型和雪花型

星型（维度建模）：事实表在中间，由维表包围；

雪花型：在星型模式的基础上，维表继续拆分；

列存储：将来自每一列的所有字段存储在一起

列压缩：位图编码

写入列存储：先进入内存中的存储，在这里被添加到一个已排序的结构中，并准备写入磁盘。当已经累计足够的写入数据时，它们将与磁盘上的列文件合并，并批量写入新文件。

聚合：数据立方体和物化视图

物化视图：是查询结果的实际副本，写入磁盘

数据立方体：每个事实具有多个维度的外键

优点：查询速度块

缺点：不具有查询原始数据的灵活性



# 二、编码和演化

向后兼容（backward compatibility）：新代码可以读旧数据

向前兼容（forward compatibility）：旧代码可以读新数据

数据的形式：

1. 在内存中，数据保存在对象、结构体、列表、数组、哈希表、树等中；
2. 将数据写入文件或通过网络发送，必须将数据编码为某种自包含的字节序列

编码（Enconding）(序列化（serialization）或编组（marshalling）):从内存到字节序列

解码（Decoding）(反序列化（deserialization）或反编组（unmarshalling）)：从字节序列到内存

## 编码数据的格式

### json,xml和二进制变体



### 二进制（需要模式定义）

**Thrift**：BinaryProtocol 和 CompactProtocol

**Protocol Buffers**(protobuf)

**Avro**

优点：不包含任何标签号码

作者模式（writer's schema）：应用程序使用它知道的任何版本的模式编码数据

读者模式（reader's schema）：应用程序按照某个模式解码数据

读取数据遇到出现在作者模式但不在读者模式中的字段，则忽略它；需要某个字段，但是作者模式不包含该名称的字段，则使用读者模式中声明的默认值填充。

向前兼容：将新版本作为编写器，旧版本作为读者

向后兼容：将旧版本作为作者，新版本作为读者

为了保证兼容性：只能添加或删除具有默认值的字段；当添加一个没有默认值的字段时，新的阅读器无法读取旧数据（破环向后兼容），删除没有默认值的字段时，旧的阅读器无法读取新作者写入的数据（破坏向前兼容）



模式的优点：

* 比"二进制JSON"变体更紧凑（省略编码数据中的字段名称）
* 比"二进制JSON"变体更紧凑（省略编码数据中的字段名称）
* 保留模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容性
* 对于静态语言用户，从模式生成代码的能力是有用的（可以在编译时进行类型检查）



## 数据流的类型

### 数据库的数据流

特点：写入数据库的过程编码，读取的过程解码

注意：较旧版本的应用程序更新以前由较新版本的应用程序编写的数据时，如果不小心，数据可能会丢失

### 服务中的数据流

代表：REST, RPC

RPC 缺陷：

* 本地调用是可预测的，并且成功或失败，这仅取决于参数；网络请求是不可预测的，由于网络问题，请求或响应可能会丢失，或者远程计算机可能很慢或者不可用，不在可控范围内；
* 本地函数要么返回结果要么抛出异常，或则和永远不返回（死循环或者程序崩溃）；网络请求可能由于超时，返回没有结果，不知道发生了什么；如果没有得到远程服务的响应，无法知道请求是否通过。
* 重试失败的网络请求，可能会发生请求实际上正在通过，只是响应丢失。重试可能导致执行多次，需要引入除重（幂等）
* 调用本地功能，耗时大致相同。网络请求调用较慢，延迟多变
* 调用本地函数时，可以将指针传递给本地内存中的对象。网络请求所有参数都要编码成可以通过网络发送的一系列字节（较大的对象可能会成为问题）



假定所有服务器都会先更新，其次是所有客户端。因此：只需要请求上向后兼容，对响应向前兼容。

可能要维护多个版本的api

### 消息传递种的数据流

优点：

- 如果收件人不可用或者过载，可以充当缓冲区，从而提高系统的可靠性
- 可以自动将消息重新发送到已经崩溃的进程，从而防止消息丢失
- 避免发件人需要知道收件人的IP地址和端口号
- 允许将一条消息发送给多个收件人
- 将发件人和收件人逻辑分离



# 总结

从简单的仅追加的存储引擎到基于 SSTable 的 LMS 树，再到面向页面的 B 树。仅追加虽然写入速度快，但是查询速度慢，LMS 保留了写了速度快的能力，使用 SSTable 提高了查询速度。因为不支持范围查询，B 树牺牲了写入速度，利用索引提高了查询速度。JSON 和 XML 虽然理解起来清晰直观，但是在网络传递过程中有冗余占用, 不够紧凑，引入Thrift、PB，减少占用。REST 适合跨数据中心，RPC 适合内部传递。消息队列能够“解耦”，提高系统可靠性。