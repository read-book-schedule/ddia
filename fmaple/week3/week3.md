# 一、复制

## 复制日志的实现

### 基于语句的复制

主库记录下它执行的每个写入请求（语句（statement）），并将该语句日志发送给其从库。

问题：

- 任何调用非确定性函数（nondeterministic）的语句，可能在每个副本上生成不同的值。Now 获取时间，或者 Rand 获取随机数。
- 如果语句使用了自增列（auto increment），或者依赖于数据库中的现有数据，则必须在每个副本上按照完全相同的顺序执行，否则产生不同的效果。当由多个并发执行的事务时，可能是限制。
- 有副作用的语句（触发器、存储过程、用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是确定的。

方案：当语句被记录时，主库可以用固定的返回值替换任何不确定的函数调用，以便从库获得相同的值。

### 传输预写日志（WAL）

日志都是包含所有数据库写入的仅追加字节序列。可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘外，主库还可以通过网络将其发送给其从库。

缺点：日志记录的数据非常底层，使复制与存储引擎紧密耦合。将存储格式更换版本时，通常不可能在主库和从库上运行不同版本的数据库软件。

### 逻辑日志复制（基于行）

复制和存储引擎使用不同的日志格式（Mysql 的二进制日志—使用基于行的配置时）。

关系数据库通常是基于行的粒度描述对数据库表的写入的记录序列：

- 对于插入的行，日志包含所有列的新值
- 对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，如果没有主键，则需要记录所有列的旧值
- 对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少所有已更改的列的新值）

优点：更容易保持向后兼容，可以多版本同时运行；外部应用程序更容易解析；

### 基于触发器的复制

触发器允许注册在数据库系统发生数据更改（写入事务）时自动执行自定义的应用程序代码。

缺点：更高的开销；更容易出错；

优点：更好的灵活性。

复制延迟问题：

1. 读己之写

   用户看不到自己的写入。

   方案：

   - 读用户可能已经修改过的内容时，都从主库读；（eg：从主库读取自己的档案，从从库读取他人的档案）
   - 如果大部分内容都可以被修改的话，从主库读已失效。需要通过跟踪上次更新时间来区分。
   - 客户端记住最近一次写入的时间戳。

2. 单调读

   用户遇到时间倒流（前后几次他人的写入数据不一致）。

   方案：确保用户总是从同一个从库读取数据（基于用户ID选择从库）

3. 一致前缀读

   复制延迟违反因果率。

   方案：如果一个系列写入按照某个顺序发生，那么任何人读取这个写入时，也会看见他们以相同顺序出现。



## 变更复制算法

### **单领导者（single leader）**

原理：

1. 副本之一被指定为领导者（leader），也称为主库（master|primary）。当客户端要想数据库写入时，它必须将请求发送给领导者，领导者会将新数据写入其本地存储。
2. 其他副本被称为追随者（followers），亦称为只读副本（read replicas），从库（slaves），备库（secondaries），热备（hot-standby）。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有追随者，称之为复制日志（replication log）记录或变更流（change stream）。每个追随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。
3. 当客户想要从数据库中读取数据时，它可以向领导者或者追随者查询。但只有领导者才能接受写操作（从客户端角度看，从库都是只读的）。

缺点：只有一个主库，而所有的写入都必须通过它。如果处于任何原因无法连接到主库，就无法向数据库写入。

设置新从库：

1. 在某个时刻获取主库的一致性快照（如果可能），而不必锁定整个数据库。
2. 将快照复制到新的从库节点。
3. 从库连接到主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。（mysql:二进制日志坐标（binlog coordinates））
4. 当从库处理完快照之后积压的数据变更，赶上了主库。现在它可以继续处理主库产生的数据变化。

处理节点宕机：

1. 从库失效：追赶恢复
2. 主库失效：故障切换

### **多领导者（multi leader）**

原理：处理写入的每个节点都必须将该数据更改转发给所有其他节点。这种情况下，每个领导者同时扮演其他领导者的追随者。

场景：

- 运维多个数据中心

- 需要离线操作的客户端

  每个设备都有一个充当领导者的本地数据库（接受写请求），存在异步的多主复制过程。

- 协同编辑

  当一个用户编辑文档时，所做的更改将立即应用到其他本地副本（Web浏览器或客户端应用程序中的文档状态），并异步复制到服务器和编辑同一文档的任何其他用户。

缺点：写冲突

处理写入冲突（两个主库同时跟新同一记录）：

- 同步与异步冲突检测

  异步：两个写入都是成功的，在稍后的时间点检测冲突（可能要求用户解决冲突为时已晚）

  同步：等待写入被复制到所有副本，再告诉用户写入成功（失去多主复制的主要优点：允许每个副本独立接受写入）

- 避免冲突

  确保来自特定用户的请求始终路由到同一数据中心，并使用该数据中心的领导者进行写入。

- 收敛至一致的状态

  所有副本必须再所有变更复制完成时收敛至一个形同的最终值。

  - 给每个写入一个唯一的ID(时间戳、随机数、UUID或者一个键和值的哈希)，挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术称为最后写入胜利（LWW, last write wins）。（容易造成数据丢失）
  - 为每个副本分配一个唯一的ID, ID编号更高的写入具有更高的优先级。（数据丢失）
  - 以某种形式将这些值合并在一起（按字母顺序排序，然后连接）
  - 在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）

- 自定义冲突解决逻辑

  - 写时执行

    只要数据库 系统检测到复制更改日志中存在冲突，就会调用冲突处理程序（在后台进程中运行，并且必须快速执行）

  - 读时执行

    检测到冲突时，所有冲突写入被存储。下一次读取数据时，会将这些多版本的数据返回给应用程序。应用程序可能会提示用户或自动解决冲突，并将结果写回数据库。

### **无领导者（leaderless）**

允许任何副本接受来自客户端的写入。

当节点故障时写入数据库：

- 读修复和反熵

  - 读修复

    当客户端并行读取多个节点时，可以检测到任何陈旧的响应，将新值写回具有陈旧响应的复制品（适合频繁阅读的值）

  - 反熵过程

    后台进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本（不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟）

- 读写的法定人数

  如果有n个副本，每个写入必须由w节点确认才能被认为时成功的，并且我们必须至为每个读查询r个节点。只要 w + r > n，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。遵循这些 r值，w值的读写称为法定人数（quorum）的读和写。r和w是有效读写所需的最低票数



# 二、分区

## **键值数据的分区**

数据倾斜：一些分区比其他分区有更多的数据和查询。

热点：不均衡导致高负载的分区称为热点。

- ### 根据键的范围分区

  原理：为每个分区指定一块连续的键范围（从最小值到最大值）

  优点：范围扫描非常简单

  缺点：某些特定的访问模式会导致热点；会有数据倾斜；

- ### 根据键的散列分区

  原理：通过散列函数（MD5）为每个分区分配一个散列范围（不是键的范围），每个通过哈希散列落在分区范围内的键将被存储在该分区中。

  缺点：范围查询比较复杂

  优点：消除数据倾斜和减少热点数据

  优化：组合索引方法（组合主键（user_id, update_timestamp）,可以有效的检索特定用户在某个时间间隔内按时间戳排序的所有更新）



## **分片与次级索引**

- ### 基于文档的分区（document-based）（也被称为本地索引（local index））

  每个列表都有一个唯一的ID—文档ID—并且用文档ID对数据库进行分区

  特点：每个分区是完全独立的：每个分区维护自己的二级索引，仅覆盖该分区中的文档；需要写入数据库（添加、删除或更新文档），只需要处理包含在当前分区的文档即可。

  分散/聚集（scatter/gather）：查询时需要将查询发送到所有分区，并合并所有返回的结果。

  优点：写入更有效率

  缺点：读取速度比较慢且比较复杂

- ### 基于关键词的分区（term-based）（也被称为全局索引（global index））

  构建一个覆盖所有分区数据的全局索引。全局索引也必须进行分区，但可以采用与主键不同的分区方式。

  优点：读取更有效率

  缺点：写入速度较慢且比较复杂；索引更新都是异步的；

## **分区再平衡**

再平衡（reblancing）：将负载从集群中的一个节点向另一个节点移动。

要求：

- 再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。
- 再平衡发生时，数据库应该继续接受读取和写入。
- 节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘I/O负载。

### **平衡策略**

- #### hash mod N（反面教材）

  节点数量N发生变化时就需要移动数据到新节点（再平衡过于昂贵）

- #### 固定数量的分区

  创建比节点更多的分区，并为每个节点分配多个分区。

  新增节点时，新节点从当前每个节点中窃取一些分区，直到分区再次公平分配。

  只有分区在节点之间的移动，分区的数量不会改变，键所指定的分区也不会改变，唯一改变的是分区所在的节点。

  缺点：需要在建立时确定分区数量（数据集的总大小难以预估，选择正确的分区数比较困难）

- #### 动态分区

  对于使用键范围分区的数据库，具有固定边界的固定数量的分区将非常不便：如果出现边界错误，则可能会导致一个分区中的所有数据或者其他分区中的所有数据为空。

  当分区增长超过配置的大小时，会被分成两个分区，每个分区约占一半的数据；当大量数据被删除并且分区缩小到某个阈值一下，则可以将其与相邻分区合并。

  优点：分区数量适应总数据量。

- #### 按节点比例分区

  每个节点具有固定数量的分区。（每个分区的大小与数据集大小成比例地增长，而节点数量保持不变，但是当增加节点时，分区将再次变小。由于较大的数据量通常需要较大数据量的节点进行存储，因此这种方法使每个分区的大小较为稳定）

  当一个新节点加入时，随机选择（适合基于散列的分区）固定数量的现有分区进行拆分，然后占有这些拆分分区中每个分区的一半，同时将每个分区的另一半留在原地。



# 三、事务

脏读：另一个事务可以看到未提交的数据

脏写：后面的写入会覆盖一个尚未提交的值

不可重复读（读取偏差）：客户端在不同时间会看见数据库的不同状态（修改导致）。

丢失更新：两个客户端同时执行读取-修改-写入序列。其中一个写操作，在没有合并到另一个写入变更情况下，直接覆盖了另一个写操作的结果。

写偏差：一个事务读取一些东西，根据它所看到的做出决定，并将决定写入数据库。但是写作的时候，决定的前提不再是真实的。

幻读：一个事务中的写入改变另一个事务的搜索查询的结果（新增或删除导致）。

## **隔离级别**

- ### 读已提交（Read Committed）

  特点：

  1. 从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））
  2. 写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））

  防止脏写：使用行锁（row-level lock）

  防止脏读：对于写入的每个对象，数据库都会记住旧的已提交值，和当前持有写入所的事务设置的新值。事务进行时，其他读取对象的事务会拿到旧值。当新值提交后，事务才会切换到读取新值。

  缺点：读取偏差（read skew）（不可重复读 nonrepeatable read）

  **为每个查询使用单独的快照**

- ### 可重复度（Repeatable-read）

  快照隔离（snapshot isolation）：每个事务从数据库的一致快照中读取—事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。

  读不阻塞写，写不阻塞读。

  多版本并发控制（MVCC，multi-version-concurrentcy control）：数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。

  **对整个事务使用相同的快照**

  缺点：丢失更新（lost update），写偏差，幻读

  防止丢失更新（并发写入导致）：

  - 原子写
  - 显式锁定
  - 自动检测丢失的更新
  - 比较并设置（CAS）
  - 冲突解决和复制

  写偏差的更多例子：

  - 会议室预定系统
  - 多人游戏
  - 抢注用户名
  - 防止双重开支

- ### 可序列化（Serializable）

  事务并行执行

  技术方案：

  - 串行顺序执行事务

    - 在存储过程中封装事务
    - 分区

  - 两阶段锁定（2PL，two-phase locking）

    悲观的并发控制机制

    - 写入阻塞其他写入，也会阻塞读
    - 使用间隙锁

  - 乐观并发控制技术（可序列化的快照隔离（SSI，serializable snapshot isolation））

    乐观的并发控制机制（如果存在潜在的危险也不阻止事务，而是继续执行事务。当一个事务提交时，数据库检查是否有什么不好的事情发生，如果是的话，事务被中止，并且必须重试）



# 总结

复制和分区都是为了高可用。由于单主复制模式在主库出问题时无法写入，引入多主复制模式（会出现写冲突）。根据键值范围分区对范围查询友好，但是可能导致数据倾斜和热点问题；根据键值的哈希分区，范围查询效率低，引入组合索引。当增加节点时需要根据不同的平衡策略来进行分区再平衡。

ACID 和 BASE ：当前关系数据库一般选用 ACID 。事务的不同隔离级别解决的问题不一样：读已提交解决了脏读问题，无法解决可重复读；可重复读无法解决丢失更新、写偏差及幻读问题；可串行化解决了丢失更新、写偏差及幻读问题，但是损耗较大。